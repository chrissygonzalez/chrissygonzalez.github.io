---
layout: post
title:      "Writing a gem is truly outrageous"
date:       2017-12-13 19:20:25 +0000
permalink:  writing_a_gem_is_truly_outrageous
---

### Setting Up
I was excited to get started when I got to the CLI gem project, so I went ahead and set up a repo and linked it to Github. This was going great! Then, as with any of the lectures, I watched Ari’s lesson about setting up a gem during my subway commute. In this case, it would have probably been better to wait until I could take notes, because I really didn’t understand what was going on. I ended up in a cycle of watching the video more closely, reading  [bundler](https://bundler.io/v1.16/guides/creating_gem.html) and [gem setup instructions](http://guides.rubygems.org/make-your-own-gem/), [reading gem naming](http://guides.rubygems.org/patterns/) [conventions](http://guides.rubygems.org/name-your-gem/), and re-creating my repo a few times before I really felt like I had things working properly. I pretty much followed the video exactly to get a CLI call method working, and then I was ready to go my own way.

### Nokogiri and the Trains
Since starting a new job in September, I commute from Brooklyn to Times Square on the subway most days, which takes at least 45 minutes one way and leaves me at the mercy of the MTA and its whims. I wanted to make a gem that did something useful, so checking the current status of subway lines seemed like an obvious choice. When I originally looked up the site the scrape for such information, I found the [MTA Emergency Website](http://alert.mta.info/), inspected its content, and decided it would be easy to scrape. Great, one decision made! I started by copying the text from a nice little [table of train statuses](https://imgur.com/a/bx2kb), formatting it as a multi-line string the way the video demonstrated (the [“heredoc”](https://ruby-doc.org/core-2.3.0/doc/syntax/literals_rdoc.html#label-Here+Documents)) and hard-coding it to respond to my call method. That looked nice, so I set up Nokogiri and started pulling in the status information for real. Each train had a name, a status, and if the status was anything other than ‘Good Service’, a link to a page with details about that line’s service. Name and status were no problem, but then I hit a snag – Nokogiri wasn’t grabbing the links at all, no matter what I tried. I got down in the weeds of reading Nokogiri elements directly and realized it wasn’t grabbing the links because they weren’t there. Whyyy?? I started to lose faith in my scraping abilities.

### There Be Javascript
It wasn’t long before I started to suspect that Javascript was my problem. Based on past jQuery experience, I knew there was a lag between the page loading and Javascript rendering, so if train information was coming from a JS file somewhere, I would expect Nokogiri to be grabbing empty divs. I was able to confirm this by digging around the Chrome dev tools network tab, which showed me what alert.mta.info looked like upon initial load ([the div where my links should be](https://imgur.com/a/VRv3K)). At least this was a google-able problem now, so armed with a name for my trouble, I searched for and found some ideas: use [Watir](http://watir.com/), or maybe [Mechanize](https://github.com/sparklemotion/mechanize) to load the page and delay scraping for a bit. Watir and Mechanize are both libraries for automating interactions with websites, mostly for testing purposes it seems, but Watir uses an actual browser to render the page, which seemed more appropriate for my needs. 

### Using Watir
I have a full-time job and a small child, so the time I have available for coding is limited to evenings after her bedtime and occasional blocks of time on the weekend. It’s not a lot of work time, but if I run into a problem I need to research, I have more freedom to fit that in during breaks at work or on the train. Researching Watir was a great opportunity to separate reading about the problem from trying to solve the problem, and I think it helped me avoid some coding messes by keeping me away from a keyboard while I was confused. I found a helpful [blog post](https://nicksardo.wordpress.com/2014/11/17/screen-scraping-in-ruby-with-watir-and-nokogiri/) and a [Stack Overflow question](https://stackoverflow.com/questions/13789583/html-is-read-before-fully-loaded-using-open-uri-and-nokogiri) that made me feel like Watir was the right choice. I also found a blog post (whose link I’ve since lost) that suggested looking at the original JS file in a similar situation, so I followed the Network tab trail through an iframe to the [JS widget](http://www.mta.info/mta-service-status-widget) that powered my page. It was here, with links that are onclick events instead of anchor elements, that I started to go down a Watir rabbit hole (you can access elements directly through Watir if you just learn [the syntax](https://markoh.co.uk/posts/finding-elements-on-page-with-watir-webdriver)!). The delay between learning this was possible at work and trying to put it into action once I got home gave me time to remember that I could just scrape the original page now. Going back to my first idea, I was able to load the page using a Watir browser, delay for a few seconds, and then parse the browser with Nokogiri. Voila! Subway detail links.

### Planned Work and Delays
At this point, scraping the actual page seemed like a trivial matter. It did end up being really easy to grab the train information, and I was able to turn that into a Train class without too much trouble. The detail pages, though, were a rat’s nest of HTML elements. If trains don’t have Good Service, they most often have Planned Work, so the first method I wrote handled the strange `b` tags containing each Planned Work item beautifully, and I felt proud. Moving on to Delays, I was sad to see their markup was completely different. Delays had text floating around the div wrapped in no tags at all, so I had to iterate through the children of the Delay `div` to grab that information in the right order. The Delay parsing ended up covering so many cases, I thought it might replace the Planned Work method, and it did. Bravo! One parser to rule them all. Status Changes were rare and short-lived and therefore hard to test, but I was confident my parser could handle them, too.

### Pipe Bombs and Status Changes
December 11 was a Monday, which I had taken off work, because December 10 was my birthday and I felt like I deserved a little free time. My plan was to work through my to-do list, including finishing up the CLI project. December 11 also turned out to be a great day not to commute to Times Square, as someone tried to bomb the subway tunnel near the Port Authority. That weird coincidence, a major subway disruption on the day I devoted to subway status gem work, exposed my parser as not working on Status Changes (at all) at a time I could do something about it. Instead of finishing up the gem and the blog post, I spent most of the day rewriting my parser and researching regexes to remove funky whitespace from my train details. In the end, I couldn’t get rid of them all, but I had something readable that now truly worked for all cases. I also managed to pack up my gem and publish it to [rubygems.org](https://rubygems.org/gems/nyc_subway_status), which turned out to be a lot more work than I’d expected. I hadn’t realized that I needed to create an executable and declare it in the gemspec, but I eventually found a [blog post](http://robdodson.me/how-to-write-a-command-line-ruby-gem/) that helped me figure it out. And with that, the ~~nyc_subway_status-0.1.0.gem~~, ~~nyc_subway_status-0.1.1.gem~~, ~~nyc_subway_status-0.1.2.gem~~, nyc_subway_status-0.1.3.gem was born!
